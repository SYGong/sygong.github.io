---
title: "3Sum"
tags: [LeetCode, Python3]
categories: LeetCode
---

## From LeetCode
[problem description](https://leetcode.com/problems/3sum/)
/
no solution provided

## Solution in Python3
```python
from collections import Counter
from bisect import bisect, bisect_left

class Solution:
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        triplets = []
        if len(nums) < 3:
            return triplets
        num_freq = Counter(nums)
        nums = sorted(num_freq)  # sorted unique numbers
        
        # Get rid of numbers that are too large/small
        # such that no other number able to complete
        nums = nums[bisect_left(nums, -2 * nums[-1]) :
                    bisect(nums, -2 * nums[0])]
        if len(nums) < 1:
            return triplets

        max_num = nums[-1]
        for i, v in enumerate(nums):
            if num_freq[v] >= 2:
                complement =  -2 * v
                if complement in num_freq:
                    if complement != v or num_freq[v] >= 3:
                        triplets.append([v] * 2 + [complement])

            # When all 3 numbers are different
            if v < 0:  # only when v is smallest
                two_sum = -v

                # lower/up bound of the smaller of remaining two
                lb = bisect_left(nums, two_sum - max_num, i + 1)
                ub = bisect(nums, two_sum // 2, lb)
                       
                for u in nums[lb : ub]:
                    complement = two_sum - u
                    if complement in num_freq and u != complement:
                        triplets.append([v, u, complement])
        return triplets
```
I am lucky to get
> Runtime: **316 ms**, faster than **99.78%** of Python3 online submissions for 3Sum.

## Variants

### Two pointers
```diff
            # When all 3 numbers are different
            if v < 0:  # only when v is smallest
                two_sum = -v

-               # lower/up bound of the smaller of remaining two
-               lb = bisect_left(nums, two_sum - max_num, i + 1)
-               ub = bisect(nums, two_sum // 2, lb)
+               # lower bound for the smaller of remaining two
+               lb = min(bisect_left(nums, two_sum - max_num, i + 1), len(nums) - 1)
+               # upper bound of the greater of remaining two
+               ub = min(bisect(nums, two_sum - nums[lb], lb + 1), len(nums) - 1)
                      
-               for u in nums[lb : ub]:
-                   complement = two_sum - u
-                   if complement in num_freq and u != complemenVt:
-                       triplets.append([v, u, complement])                      
+               while lb < ub:
+                   if nums[lb] + nums[ub] == two_sum:
+                       triplets.append([v, nums[lb], nums[ub]])
+                       lb += 1
+                       ub -= 1
+                   elif nums[lb] + nums[ub] > two_sum:
+                       ub -= 1
+                   else:
+                       lb += 1

```
This solution is not bad, it has:
> Runtime: 828 ms, faster than 88.08% of Python3 online submissions for 3Sum.

In case we can't get binary search effortless, let `lb = i + 1` and `ub = len(nums) - 1`. My first solution don't have any function from `bisect` and it still beats **52.17%**.

### Remove duplicated triplets
This problem is difficult only because we need many conditions to keep all triplets are unique. If we handle duplicates seperately, it could be easier to write and read. However, it may not worth the effort to compare triplets given the data structure we have by hand. It will also sacrifice runtime.

### Sum up to arbitrary value `target`
It is not hard to make our program more general, for example
```diff
-           if v < 0:  # only when v is smallest
+           if v * 3 < target:  # only when v is smallest
```
